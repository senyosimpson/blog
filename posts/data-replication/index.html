<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="en-us">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Data replication in distributed systems | Bloom</title>

<meta property='og:title' content='Data replication in distributed systems - Bloom'>
<meta property='og:description' content='I&rsquo;ve been reading the book Designing Data-Intensive Applications by Martin Kleppmann. Chapter 5 of the book takes a deep dive into the world of data replication in distributed systems. I have always carried the assumption that data replication is non-trivial but reading the chapter opened my eyes to its true complexity. This post is a summary of the chapter - it can be considered a set of notes. Let&rsquo;s do this ðŸš€'>
<meta property='og:url' content='http://senyosimpson.com/posts/data-replication/'>
<meta property='og:site_name' content='Bloom'>
<meta property='og:type' content='article'><meta property='og:image' content='http://ithare.com/wp-content/uploads/BB_part116_BookChapter017b_v1.png'><meta property='article:published_time' content='2020-10-12T00:00:00Z'/><meta property='article:modified_time' content='2020-10-12T00:00:00Z'/><meta name='twitter:card' content='summary_large_image'><meta name='twitter:site' content='@senyo_simpson'><meta name='twitter:creator' content='@senyo_simpson'><meta name='twitter:image' content='http://ithare.com/wp-content/uploads/BB_part116_BookChapter017b_v1.png'>

<link rel="stylesheet" href="/css/style.css"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<link rel="canonical" href="http://senyosimpson.com/posts/data-replication/">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
<script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
  
    window.addEventListener('load', (event) => {
        document.querySelectorAll("mjx-container").forEach(function(x){
          x.parentElement.classList += 'has-jax'})
      });
  
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
   src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<section class="section">
  <div class="container">
    <nav id="nav-main" class="nav">
      <div id="nav-name" class="nav-left">
        <a id="nav-anchor" class="nav-item" href="http://senyosimpson.com">
          <h1 id="nav-heading" class="title is-4">Bloom</h1>
        </a>
      </div>
      <div class="nav-right">
        <nav id="nav-items" class="nav-item level is-mobile"><a class="level-item" aria-label="twitter" href='https://twitter.com/senyo_simpson'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="github" href='https://github.com/senyosimpson'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="linkedin" href='https://linkedin.com/in/senyo-simpson-997951157'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path stroke-width="1.8" d="m5.839218,4.101561c0,1.211972 -0.974141,2.194011 -2.176459,2.194011s-2.176459,-0.982039 -2.176459,-2.194011c0,-1.211094 0.974141,-2.194011 2.176459,-2.194011s2.176459,0.982917 2.176459,2.194011zm0.017552,3.94922l-4.388022,0l0,14.04167l4.388022,0l0,-14.04167zm7.005038,0l-4.359939,0l0,14.04167l4.360816,0l0,-7.370999c0,-4.098413 5.291077,-4.433657 5.291077,0l0,7.370999l4.377491,0l0,-8.89101c0,-6.915523 -7.829986,-6.66365 -9.669445,-3.259423l0,-1.891237z"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="email" href='mailto:simpsonsenyo@gmail.com'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
    <polyline points="22,6 12,13 2,6"/>
    
  </svg></i>
            </span>
          </a></nav>
      </div>
    </nav>

    <nav class="nav">
      
      <div class="nav-left"><a class="nav-item" href="/about">
          <h2 class="title is-5">About</h2>
        </a><a class="nav-item" href="/essays">
          <h2 class="title is-5">Essays</h2>
        </a></div>
      

      
    </nav>

  </div>
  <script src="/js/navicon-shift.js"></script>
</section>
<section class="section">
  <div class="container">
    <div class="subtitle tags is-6 is-pulled-right">
      
    </div>
    <h2 class="subtitle is-6">October 12, 2020</h2>
    <h1 class="title">Data replication in distributed systems</h1>
    
    <div class="content">
      <p>I&rsquo;ve been reading the book <a href="https://dataintensive.net" target="_blank" rel="noreferrer noopener">Designing Data-Intensive Applications</a> by Martin Kleppmann.  Chapter 5 of the book takes a deep dive into the world of data replication in distributed systems. I have always carried the assumption that data replication is non-trivial but reading the chapter opened my eyes to its true complexity. This post is a summary of the chapter - it can be considered a set of notes. Let&rsquo;s do this ðŸš€</p>
<h1 id="what-is-data-replication">What is data replication?</h1>
<p>Data replication is the act of copying the <em>same</em> data across multiple machines. This is common practice in the development of highly-available software systems. The two leading reasons for data replication:</p>
<ul>
<li>In the event one database stops working, the system can continue operating</li>
<li>To improve the performance of the system. By having replicas, load can be distributed across them</li>
</ul>
<p>The complexity of data replication comes down to managing changes to the data. Propagating changes to all replicas and guaranteeing they have arrived at the same state is non-trivial. The three main algorithms for replicating changes are: single-leader, multi-leader and leaderless replication.</p>
<h1 id="single-leader-replication">Single-leader replication</h1>
<p>The most common solution for replicating changes is <em>leader-based replication</em>. In leader-based replication, all writes are submitted to the primary database, a.k.a the leader. The leader sends the changes to the replica databases, a.k.a the followers. This strategy ensures that all the databases contain the same data. The benefit is that reads can be handled by any of the databases (the leader or the followers). This improves the performance of the overall system as the load is distributed across all the databases.</p>
<figure>
    <img src="/images/data-replication/leader-followers.png"/> 
</figure>

<h2 id="synchronous-vs-asynchronous-replication">Synchronous vs asynchronous replication</h2>
<p>Data replication can be done in a synchronous or asynchronous fashion. In synchronous replication, a request is only successful after the last replica has successfully completed the request. This has the advantage of ensuring that data has been successfully replicated across all the replicas. The disadvantage is that if any replica fails to process the request (for example due to a networking issue), the request fails even though some of the replicas may have the relevant data. Alongside this, if any of the replicas are slow to process the request, the response time becomes unacceptable. In asynchronous replication, the request is successful once the leader has processed it. This is advantageous as requests are handled quickly (unless the leader itself is under strain) and writes can still be processed if any number of replicas fail. However, this pattern means writes are not durable; if the leader fails and is not recoverable, writes that have not been replicated are lost.</p>
<h2 id="how-to-deal-with-failure">How to deal with failure</h2>
<p>As mentioned, a core advantage of using replication is to improve the availability of the system - it can operate even if replicas become unavailable. There are two scenarios we have to consider: when a <em>replica</em> fails and when a <em>leader</em> fails.</p>
<h3 id="replica-failure">Replica failure</h3>
<p>Every replica keeps a log of the data changes it has received from the leader on disk. If it fails, it uses its log to identify the last transaction it successfully processed. It can then request all subsequent changes it has not processed from the leader and apply them. Once it has recovered, it can continue receiving requests. This process is called <em>catch-up recovery</em></p>
<h3 id="leader-failure">Leader failure</h3>
<p>Leader failure is more difficult to handle. If a leader fails, one of the replicas must be promoted to leader, client requests need to be routed to the new leader and the replicas must consume data changes from the new leader. This process is known as <em>failover</em>. Failover comes with its own set of challenges:</p>
<ul>
<li>If asynchronous replication is used, the new leader may not have receieved all the writes from the old leader before it failed. If the old leader rejoins, the extra writes it has processed have to be dealt with. Commonly this is done by discarding the writes. Unfortunately, this negatively impacts the durability guarantee.</li>
<li>It&rsquo;s possible for two replicas to believe they are the leader. This is known as <em>split brain</em>. If both begin accepting writes and there is no method for resolving write conflicts, data can be lost or corrupted.</li>
<li>How do we know for certain that a leader is dead? Often a timeout is used - if the leader does not respond in a certain amount of time, it is declared dead. If this timeout is too short, we run the risk of performing unnecessary failovers. If it is too long, the system takes longer to recover.</li>
</ul>
<h2 id="under-the-hood-of-leader-based-replication">Under the hood of leader-based replication</h2>
<p>By now, I&rsquo;m sure you&rsquo;re curious to know how is replication implemented. There are a few common methods.</p>
<h3 id="statement-based-replication">Statement-based replication</h3>
<p>In statement-based replication, the sql statement itself is passed onto replicas. When a write request is received by the leader, it logs the sql statement and propagates it to the replicas. This approach has a few failure modes:</p>
<ul>
<li>If a statement contains a nondeterministic function, the writes will be different. For example, if the statement needs the current time, each replica will have a slightly different time.</li>
<li>Statements that have side effects (e.g a trigger) will be repeatedly called. This is not ideal as it is a waste of computation and may lead to slightly differing results if the side effect is nondeterministic.</li>
</ul>
<h3 id="write-ahead-log-shipping">Write-ahead-log shipping</h3>
<p>Databases usually keep a log containing information of every write processed. This log can be used to build a replica of the database. Using this method, the leader writes every write to the log and propagates the log to each replica. The replica processes the log and builds the data as it is on the leader. The disadvantage with this method is that a log usually describes the data on a low-level - it contains details of which bytes were changed in which disc blocks. This tightly couples the replication process and the storage engine; if the database storage format changes, you have to upgrade the entire fleet of databases at once since the leader and followers cannot have different versions. This makes it impossible to have zero-downtime upgrades - this is unacceptable for many companies.</p>
<h3 id="logical-log-replication">Logical log replication</h3>
<p>To decouple the replication process and storage engine, different log formats can be used for the storage engine and replication. The replication log is called a <em>logical log</em>. This log contains information about writes to the database at a row level.</p>
<ul>
<li>For an inserted row, the log contains new values for all columns</li>
<li>For a deleted row, the log contains enough information to identify the deleted row</li>
<li>For an updated row, the log contains enough information to identify the updated row and the new values for the changed columns</li>
</ul>
<p>Using a logical log allows for zero-downtime upgrades. Another benefit is that it is easier for external applications to parse a logical log - this proves useful if there is a need to send the contents of a database to an external system such as a data warehouse.</p>
<h2 id="replication-lag">Replication lag</h2>
<p>Leader-based replication is great for workloads that mainly consist of reads and few writes. The leader is responsible for processing all the writes while read requests are distributed amongst replicas. This is known as a <em>read-scaling</em> architecture. It is only practical with the use of asynchronous replication. When a write is made, there is a replication lag - the time it takes for the write to be propagated and applied by the replica. After some time (usually a fraction of a second), all replicas will have the same data and <em>become consistent</em>. This is known as <em>eventual consistency</em>. Eventual consistency brings its own set of challenges.</p>
<h3 id="read-your-own-writes">Read your own writes</h3>
<p>Imagine a scenario where a user updates her profile and views it immediately after. The update is a write request which is handled by the leader and propagated to the replicas. The viewing of her profile is a read request and can be handled by any of the replicas. It can so happen that the replica has not processed the write by the time she views her profile, showing her stale data.</p>
<figure>
    <img src="/images/data-replication/read-your-writes.png"/> 
</figure>

<p>This situation requires <em>read-after-write consistency</em>, also known as <em>read-your-writes consistency</em>. This ensures that a user will always see the updated data they submitted <em>themselves</em> but makes no claim as to what state the data will be for other users, i.e the data you view of other users may be stale. There are a number of ways to implement this:</p>
<ul>
<li>If you are reading something the user modified, read it from the leader otherwise read it from the follower. This requires you to know what data was modified. There are simple heuristics one can employ instead of actually tracking this. For example, a user is the only person that can edit their own profile so a simple rule is: always read a user&rsquo;s own profile from the leader</li>
<li>Keep track of when an update was made. For a window period (e.g one minute), read from the leader. After that period has elapsed, read from the follower.</li>
<li>The client keeps track of its latest write via a timestamp. The system can ensure whenever a read request occurs, the replica serving the request has data up until that timestamp. If it does not, it can be serviced by another replica or the leader.</li>
</ul>
<h3 id="monotonic-reads">Monotonic reads</h3>
<p>If a user makes several reads from different replicas, it&rsquo;s possible for a user to see things go back in time. Time travel, how rad ðŸ˜†. Let&rsquo;s take an example scenario. A user, Kojo, makes a new comment. This is processed by the leader and is propagated to replicas A and B. Replica A applies the write immediately but there is a lag with replica B. Another user, Kwaku, reads the post where the comment was made. This read request is handled by replica A and so Kwaku sees the new comment. He then refreshes the post. This time, the read is handled by replica B but this replica is suffering from a lag and therefore hasn&rsquo;t processed the comment yet. When Kwaku refreshes the post, the comment is gone! In this sense, he&rsquo;s time traveled to the past ðŸš€.</p>
<figure>
    <img src="/images/data-replication/monotonic-reads.png"/> 
</figure>

<p>Montonic reads are a guarantee that this effect will never happen i.e if they make multiple requests, they never see time go backwards. One method for achieving this is to simply route requests to the same replica for a given user.</p>
<h3 id="consistent-prefix-reads">Consistent prefix reads</h3>
<p>A class of errors can be attributed to violating causality. In this scenario, Kojo and Kwaku are chatting. Another user, Abele is observing the conversation. Kojo asks Kwaku, &ldquo;How are you doing?&rdquo;. Kwaku replies to Kojo saying, &ldquo;I&rsquo;m good&rdquo;. So we have two writes that need to occur. In our database design, there is a leader and follower for Kojo and a separate leader and follower for Kwaku. Since Abele is just reading, his reads come from the respective followers. When Kojo sends his message, it is processed by the leader but the replication lag is longer than normal. Kwaku replies and his message is processed by his leader and is immediately replicated by the replica. When Abele reads, he gets Kwaku&rsquo;s reply first and then later gets Kojo&rsquo;s initial question. The causal link between the messages is now broken.</p>
<figure>
    <img src="/images/data-replication/consistent-prefix.png"/> 
</figure>

<p>Consistent prefix reads are a guarantee that anyone reading a set of writes reads them in the order they were written. This problem is magnified in partitioned databases. Partitions act independently; there is no global ordering of writes to the system. When a user reads, they may see parts of the database in an older state and others in a newer state. A solution to this is to write all causally related writes to the same partition.</p>
<h2 id="multi-leader-replication">Multi-leader replication</h2>
<p>One obvious shortcoming with single-leader replication is that there is only a single leader. All writes have to be processed by this leader. If it goes down or cannot be reached, you cannot process any writes. A simple extension is to allow for multiple replicas to be leaders. In this setup, a write can be processed by any of the leaders and the changes are propagated to all other replicas (including the other leaders). A multi-leader setup introduces additional complexity. This often outweighs the advantages of using a multi-leader setup, however, there are a number of use cases where it reasonable to do so. An example is a multi-datacenter database. In this setup, a database is replicated across different datacenters. This is often to handle an entire datacenter going offline. In a single-leader setup, the leader will be in only <em>one</em> datacenter and the changes will need to be replicated across all the datacenters from there. In a multi-leader setup, <em>each</em> datacenter has its own leader - the single-leader configuration exists within each datacenter. When a write occurs in a given datacenter, the leader propagates the changes to the other leaders in the other datacenters.</p>
<h3 id="write-conflicts">Write conflicts</h3>
<p>One of the biggest challenges with a multi-leader setup is handling write conflicts. Let&rsquo;s take a scenario where Kojo and Kwaku are collaboratively editing a document. Kojo changes the title of the document from A to B. Kwaku also changes the title from A to C at the same time. Both changes are accepted by their local leaders but when the each leader propagates the change to the other database, a conflict occurs.</p>
<figure>
    <img src="/images/data-replication/write-conflict.png"/> 
</figure>

<p>The simplest method of handling write conflicts is avoiding them. If an application ensures that all writes go through the same leader, a write conflict cannot occur. Surprisingly, this is often the recommended approach as dealing with write conflicts is complex. Some other strategies for handling conflicts:</p>
<ul>
<li>Give each write a unique ID (e.g timestamp). The one with the highest number ID is used and the other writes are thrown away. This is known <em>last-write-wins</em>.</li>
<li>Give each replica a unique ID. The one with the highest ID takes precedence over the others. Its write is applied while the others are discarded.</li>
<li>Record the conflict elsewhere and write application code that handles the conflict.</li>
</ul>
<h1 id="leaderless-replication">Leaderless replication</h1>
<p>In leaderless replication systems, any replica can process writes. The advantage of a leaderless system is improved fault-tolerance.</p>
<h2 id="writing-when-a-node-is-down">Writing when a node is down</h2>
<p>In a leaderless system, writes are sent to each replica in parallel. Imagine a scenario where we have 3 replicas and 1 is down. When a write request enters the system, two of the three replicas successfully process the request. The system is configured such that if two out of three replicas process the request, the request is considered successful. When the unavailable replica recovers and comes online again, if it receives read requests it will return stale data. To solve this, read requests are sent in parallel to each replica and the most recent value is returned to the client.</p>
<h3 id="achieving-consistency">Achieving consistency</h3>
<p>It is important to achieve eventual consistency - all replicas have the most recent data. There are two common mechanisms for this, <em>read repair</em> and <em>anti-entropy process</em>. In read repair, the database system can detect stale data on read and subsequently update it. This is an effective technique when data is read frequently. An anti-entropy process is a continuous process that looks for differences in data across all replicas and copies any missing data to stale replicas to keep them up to date.</p>
<h2 id="quorum">Quorum</h2>
<p>In the scenario above, we considered a write request successful if two out of three replicas processed the request. This may seem counter-intuitive; how do we guarantee we will never receive stale data? If we know that every successful write is guaranteed to be present on at least two out of three replicas, that means at most one replica can be stale. If a read request is processed by at least two replicas we can guarantee one of the responses will be up to date.</p>
<p>We can formalize this concept. If there are $n$ replicas, each write must be processed successfully by $w$ nodes and reads must be processed by at least $r$ nodes. We can guarantee up to date reads if $w + r &gt; n$. For our example, we had $n=3, w=2, r=2$. This satisfies the constraint. Reads and writes that abide by this constraint are called <em>quorum</em> reads and writes. The quorom condition allows the system to process requests if nodes are unavailable:</p>
<ul>
<li>If $w &lt; n$, we can still process write requests</li>
<li>If $r &lt; n$, we can still process read requests</li>
</ul>
<p>If fewer than $r$ or $w$ replicas are available, then we cannot process reads or writes.</p>
<h3 id="limitations-of-quorum-consistency">Limitations of quorum consistency</h3>
<p>Even with the quorum condition satisfied, there are edge cases that can arise. These are often unrelated to quorum itself but the nature of distributed systems.</p>
<ul>
<li>If sloppy quorum is used, the replicas written to and read from are not guaranteed to overlap.</li>
<li>If a write and read happen concurrently, it is undetermined whether the read response is of the old or new value.</li>
<li>If a write succeeds on fewer than <em>w</em> replicas, the write is not rolled back on the replicas it succeeded on. When a read request occurs, it may or may not return the value from the read</li>
<li>If a replica with a new value fails and is restored from a replica with an old value, the number of replicas storing the new value may fall below $w$.</li>
</ul>
<h3 id="sloppy-quorum">Sloppy Quorum</h3>
<p>As mentioned earlier, quorum is not as fault-tolerant as it is said to be due to the nature of distributed systems. This results in some difficult design decisions. Imagine we have a cluster with 9 replicas. Even though we have 9 replicas, we set $n$ to 3 and $w=r=2$. In this scheme, we effectively have 3 partitions each containing 3 replicas. Of that, a particular value only needs to exist on one of those partitions and satisfy the quorum constraint to ensure we always have up to date responses. This, however, can go wrong. A network interruption occurs which cuts off a client to a number of replicas. The replicas its cut off from contain <em>some</em> of the replicas needed to guarantee the quorum condition is met. For example, of the 9 replicas, it is cut off from 4 and 2 of those are from one partition needed to ensure quorum for a particular read request. In this case we have a design choice:</p>
<ol>
<li>We return errors to all requests as we cannot reach quorum</li>
<li>We process write requests and write to them to nodes that are reachable but are not part of the partition where the value is located</li>
</ol>
<p>The second option is referred to as <em>sloppy quorum</em>. We still need to satisfy the quorum condition but there is no guarantee the replicas are from the partition where the value is located. Once the other replicas are online again, the writes are sent to those replicas. This is known as <em>hinted handoff</em>. Sloppy quorum is useful when there is a requirement for high-availability for writes. In reality, sloppy quorum is not quorum - it does not guarantee you will read the most up to date value. It is a guarentee of durability - the data will be stored on $w$ nodes somewhere.</p>
<h2 id="detecting-concurent-writes">Detecting concurent writes</h2>
<p>Many leaderless replication systems allow for concurrent writes. This will inevitably lead to write conflicts. The main problem is that the order of writes may differ at different replicas. This can be due to multitude of factors: variable network delays, network interruptions, partial failures, etc. In the image below, we have two replicas and two clients, A and B.</p>
<ul>
<li>Replica one receives the request from A and then B.</li>
<li>Replica two receives the request from B and then A.</li>
</ul>
<figure>
    <img src="/images/data-replication/concurrent-writes.png"/> 
</figure>

<p>The concurrent writes have lead to differing end results in each replica. When a read occurs, replica one will return B but replica two will return A. In order to be eventually consistent, the nodes should converge to the same value. There are some methods for handling this.</p>
<h3 id="last-write-wins">Last write wins</h3>
<p>Last write wins uses the most recent write as the convergent value and discards the other values. While it can be implemented, it does not make much sense. As the writes happen concurrently, there is no true &ldquo;most recent&rdquo; value. It is done by enforcing an order on the writes. For example, we can use timestamps to enforce this order. Unfortunately, last write wins trades-off durability - data is lost in the conflict resolution process.</p>
<h3 id="version-vectors">Version Vectors</h3>
<p>Version vectors use a set of version numbers to deal with concurrent writes. A version number is a monotonically increasing number that is incremented every time a write operation occurs. This version number is sent with all write requests, allowing the system to determine if a concurrent write occured and then apply a strategy to deal with it. Taking the example from the book, we have two clients buying groceries on an online store, concurrently adding items to the same shopping cart.</p>
<ol>
<li>Client 1 adds <em>milk</em> to the cart. This is the first write so the version number is incremented to 1 and the cart is updated to <strong>[milk]</strong>. The version number and the cart state are sent back to the client.</li>
<li>Client 2 adds <em>eggs</em> to the cart concurrently. The client did not know milk had been added to the basket already. The version number is incremented to 2 and the milk and eggs are stored as two <em>separate</em> values. Therefore the value of the cart is <strong>[[milk], [eggs]]</strong> The server sends back the version number and both the values of the cart.</li>
<li>Client 1 wants to add <em>flour</em> to the cart. From their perspective, the cart should contain <strong>[milk, flour]</strong> after the update. When requesting to add the flour, the version number and request are sent to the server. The version number is the one stored on the client side - in this case it is 1. The database can determine that a concurrent write occured. The value <strong>[milk, flour]</strong> occurs after the value of <strong>[milk]</strong>. However, considering the other client added eggs to the cart and that is not contained in the new value, it is straightforward to see that the request to add flour occured concurrently to adding eggs to the cart. The value <strong>[milk, flour]</strong> is assigned version number 3. Version number 1 and its value are overwritten. Version number 2 and its value <strong>[eggs]</strong> is kept.</li>
</ol>
<figure>
    <img src="/images/data-replication/version-vectors.png"/> 
</figure>

<p>Version vectors are an extension of this, they contain version numbers of each replica. This ensures it is safe to read from one replica and subsequently write back to another replica.</p>

      
    </div>
    
  </div>
</section>



<section class="section">
  <div class="container has-text-centered">
    <p></p>
    
      <p>Powered by <a href="https://gohugo.io/">Hugo</a> &amp; <a href="https://github.com/ribice/kiss">Kiss</a>.</p>
    
  </div>
</section>



</body>
</html>

